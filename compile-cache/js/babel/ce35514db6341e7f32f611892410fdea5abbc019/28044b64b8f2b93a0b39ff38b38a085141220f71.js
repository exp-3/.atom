'use babel';

//
// Standard error format parser.
//

Object.defineProperty(exports, '__esModule', {
  value: true
});
var err = require('./errors');

// Detects message headers (the main message and location):
//
// Examles:
//
// error[E0023]: Some error message
//   --> src/main.rs:157:12
//
// <std macros>:1:33: 1:58 Some message
//
// src/main.rs:157:12: 157:18 Some message
//
// error: Something happened
//
// Retursn the message infromation and the number of parsed lines.
function parseMessageHeader(lines, i) {
  var match = /^(error|warning|note|help)(?:\[(E\d+)\])?: (.*)/.exec(lines[i]);
  if (match) {
    var level = match[1];
    var code = match[2];
    var message = match[3];
    if (lines.length >= i) {
      var locMatch = /^\s*--> (.+):(\d+):(\d+)/.exec(lines[i + 1]);
      if (locMatch) {
        var locFile = locMatch[1];
        var locLine = parseInt(locMatch[2], 10);
        var locColStart = parseInt(locMatch[3], 10);
        var msg = {
          message: message,
          type: err.level2type(level),
          severity: err.level2severity(level),
          file: locFile,
          line: locLine,
          line_end: locLine,
          col: locColStart,
          col_end: locColStart + 1, // Highlight only one symbol by default
          trace: [],
          extra: {
            errorCode: code
          }
        };
        return {
          message: msg,
          parsedQty: 2 // Number of parsed lines
        };
      }
    }
  }

  // Try the format that is usually found in errors within macros:
  // file_name:l:c: le:ce: message
  var macroMatch = /^\s*(.+):(\d+):(\d+): (\d+):(\d+) (error|warning|note|help):\s*(.*)/.exec(lines[i]);
  if (macroMatch) {
    var msg = {
      message: macroMatch[7],
      type: err.level2type(macroMatch[6]),
      severity: err.level2severity(macroMatch[6]),
      file: macroMatch[1],
      line: parseInt(macroMatch[2], 10),
      line_end: parseInt(macroMatch[4], 10),
      col: parseInt(macroMatch[3], 10),
      col_end: parseInt(macroMatch[5], 10),
      trace: [],
      extra: {}
    };
    return {
      message: msg,
      parsedQty: 1 // Number of parsed lines
    };
  }

  // Try the simplest format:
  // error: message
  var simpleMatch = /^\s*(error|warning|note|help):\s*(.*)/.exec(lines[i]);
  if (simpleMatch) {
    var msg = {
      message: simpleMatch[2],
      type: err.level2type(simpleMatch[1]),
      severity: err.level2severity(simpleMatch[1]),
      trace: [],
      extra: {}
    };
    return {
      message: msg,
      parsedQty: 1 // Number of parsed lines
    };
  }

  return undefined;
}

// Parses a code block. If a message provided, extracts the additional info (the span length,
// the additional text etc) from the block and modifies the message info accordingly.
//
// Examle:
//
//    |
// 12 |    some code here
//    |         ^^^^ additional text
//    = note: additional note
//
// Returns the number of parsed lines.
function parseCodeBlock(lines, i, msg) {
  var l = i;
  var spanLineNo = -1;
  while (l < lines.length && lines[l] !== '') {
    var line = lines[l];
    var lineParsed = false;
    var codeMatch = /^\s*(\d*)\s*\|.*/.exec(line);
    if (codeMatch) {
      if (codeMatch[1].length > 0) {
        spanLineNo = parseInt(codeMatch[1], 10);
      } else {
        var spanMatch = /^[\s\d]*\|(\s+)([\^-]+)\s*(.*)/.exec(line);
        if (spanMatch) {
          // The line contains span highlight
          var startCol = spanMatch[1].length;
          var light = spanMatch[2];
          var label = spanMatch[3].length > 0 ? spanMatch[3] : undefined;
          if (light[0] === '^') {
            // It's the primary span. Copy the highlighting infro to the main message
            msg.col_end = msg.col + light.length;
            msg.extra.spanLabel = label;
          } else if (light[0] === '-' && label) {
            // It's a secondary span, create a submessage
            msg.trace.push({
              message: label,
              type: 'Note',
              severity: 'info',
              file: msg.file,
              line: spanLineNo,
              line_end: spanLineNo,
              col: startCol,
              col_end: startCol + light.length,
              extra: {}
            });
          }
        }
      }
      lineParsed = true;
    } else {
      var auxMatch = /^\s*= (note|help): (.+)/.exec(line);
      if (auxMatch) {
        msg.trace.push({
          message: auxMatch[2],
          type: err.level2type(auxMatch[1]),
          severity: err.level2severity(auxMatch[1]),
          extra: {}
        });
        lineParsed = true;
      }
    }
    if (!lineParsed && line.startsWith('...')) {
      // Gaps in the source code are displayed this way
      lineParsed = true;
    }
    // TODO: Backward compatibility with Rust prior to 1.12. Remove this if-block when there's no need to support it.
    if (!lineParsed && (/^[^:]*:(\d+)\s+.*/.test(line) || /^\s+\^.*/.test(line))) {
      lineParsed = true;
    }
    if (lineParsed) {
      l += 1;
    } else {
      break;
    }
  }

  return l - i;
}

function parseMessageBlock(lines, i, messages, parentMsg) {
  var l = i;
  var headerInfo = parseMessageHeader(lines, i);
  if (headerInfo) {
    // TODO: Backward compatibility with Rust prior to 1.12. Remove this if-block when there's no need to support it.
    if (parentMsg && (headerInfo.message.severity === 'error' || headerInfo.message.severity === 'warning') || !parentMsg && headerInfo.message.severity !== 'error' && headerInfo.message.severity !== 'warning') {
      return 0;
    }
    // Message header detected, remember it and continue parsing
    l += headerInfo.parsedQty;
    if (parentMsg) {
      // We are parsing a submessage, add it to trace
      parentMsg.trace.push(headerInfo.message);
    } else {
      // We are parsing the main message
      messages.push(headerInfo.message);
    }
    l += parseCodeBlock(lines, l, headerInfo.message);
    // If it's the main message, parse its submessages
    if (!parentMsg) {
      while (l < lines.length) {
        var subParsedQty = parseMessageBlock(lines, l, messages, headerInfo.message);
        if (subParsedQty > 0) {
          l += subParsedQty;
        } else {
          break;
        }
      }
    }
  }

  return l - i;
}

var tryParseMessage = function tryParseMessage(lines, i, messages) {
  return parseMessageBlock(lines, i, messages, null);
};

exports.tryParseMessage = tryParseMessage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3Rha2Fha2kvLmF0b20vcGFja2FnZXMvYnVpbGQtY2FyZ28vbGliL3N0ZC1wYXJzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxDQUFDOzs7Ozs7Ozs7QUFNWixJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQmhDLFNBQVMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtBQUNwQyxNQUFNLEtBQUssR0FBRyxpREFBaUQsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0UsTUFBSSxLQUFLLEVBQUU7QUFDVCxRQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsUUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLFFBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QixRQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO0FBQ3JCLFVBQU0sUUFBUSxHQUFHLDBCQUEwQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0QsVUFBSSxRQUFRLEVBQUU7QUFDWixZQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUIsWUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMxQyxZQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzlDLFlBQU0sR0FBRyxHQUFHO0FBQ1YsaUJBQU8sRUFBRSxPQUFPO0FBQ2hCLGNBQUksRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztBQUMzQixrQkFBUSxF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QUM7O1FBRU8sZUFBZSxHQUFmLGVBQWUiLCJmaWxlIjoiL2hvbWUvdGFrYWFraS8uYXRvbS9wYWNrYWdlcy9idWlsZC1jYXJnby9saWIvc3RkLXBhcnNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuXG4vL1xuLy8gU3RhbmRhcmQgZXJyb3IgZm9ybWF0IHBhcnNlci5cbi8vXG5cbmNvbnN0IGVyciA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbi8vIERldGVjdHMgbWVzc2FnZSBoZWFkZXJzICh0aGUgbWFpbiBtZXNzYWdlIGFuZCBsb2NhdGlvbik6XG4vL1xuLy8gRXhhbWxlczpcbi8vXG4vLyBlcnJvcltFMDAyM106IFNvbWUgZXJyb3IgbWVzc2FnZVxuLy8gICAtLT4gc3JjL21haW4ucnM6MTU3OjEyXG4vL1xuLy8gPHN0ZCBtYWNyb3M+OjE6MzM6IDE6NTggU29tZSBtZXNzYWdlXG4vL1xuLy8gc3JjL21haW4ucnM6MTU3OjEyOiAxNTc6MTggU29tZSBtZXNzYWdlXG4vL1xuLy8gZXJyb3I6IFNvbWV0aGluZyBoYXBwZW5lZFxuLy9cbi8vIFJldHVyc24gdGhlIG1lc3NhZ2UgaW5mcm9tYXRpb24gYW5kIHRoZSBudW1iZXIgb2YgcGFyc2VkIGxpbmVzLlxuZnVuY3Rpb24gcGFyc2VNZXNzYWdlSGVhZGVyKGxpbmVzLCBpKSB7XG4gIGNvbnN0IG1hdGNoID0gL14oZXJyb3J8d2FybmluZ3xub3RlfGhlbHApKD86XFxbKEVcXGQrKVxcXSk/OiAoLiopLy5leGVjKGxpbmVzW2ldKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBtYXRjaFsxXTtcbiAgICBjb25zdCBjb2RlID0gbWF0Y2hbMl07XG4gICAgY29uc3QgbWVzc2FnZSA9IG1hdGNoWzNdO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPj0gaSkge1xuICAgICAgY29uc3QgbG9jTWF0Y2ggPSAvXlxccyotLT4gKC4rKTooXFxkKyk6KFxcZCspLy5leGVjKGxpbmVzW2kgKyAxXSk7XG4gICAgICBpZiAobG9jTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbG9jRmlsZSA9IGxvY01hdGNoWzFdO1xuICAgICAgICBjb25zdCBsb2NMaW5lID0gcGFyc2VJbnQobG9jTWF0Y2hbMl0sIDEwKTtcbiAgICAgICAgY29uc3QgbG9jQ29sU3RhcnQgPSBwYXJzZUludChsb2NNYXRjaFszXSwgMTApO1xuICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICB0eXBlOiBlcnIubGV2ZWwydHlwZShsZXZlbCksXG4gICAgICAgICAgc2V2ZXJpdHk6IGVyci5sZXZlbDJzZXZlcml0eShsZXZlbCksXG4gICAgICAgICAgZmlsZTogbG9jRmlsZSxcbiAgICAgICAgICBsaW5lOiBsb2NMaW5lLFxuICAgICAgICAgIGxpbmVfZW5kOiBsb2NMaW5lLFxuICAgICAgICAgIGNvbDogbG9jQ29sU3RhcnQsXG4gICAgICAgICAgY29sX2VuZDogbG9jQ29sU3RhcnQgKyAxLCAgLy8gSGlnaGxpZ2h0IG9ubHkgb25lIHN5bWJvbCBieSBkZWZhdWx0XG4gICAgICAgICAgdHJhY2U6IFtdLFxuICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IGNvZGVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgIHBhcnNlZFF0eTogMiAgICAvLyBOdW1iZXIgb2YgcGFyc2VkIGxpbmVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVHJ5IHRoZSBmb3JtYXQgdGhhdCBpcyB1c3VhbGx5IGZvdW5kIGluIGVycm9ycyB3aXRoaW4gbWFjcm9zOlxuICAvLyBmaWxlX25hbWU6bDpjOiBsZTpjZTogbWVzc2FnZVxuICBjb25zdCBtYWNyb01hdGNoID0gL15cXHMqKC4rKTooXFxkKyk6KFxcZCspOiAoXFxkKyk6KFxcZCspIChlcnJvcnx3YXJuaW5nfG5vdGV8aGVscCk6XFxzKiguKikvLmV4ZWMobGluZXNbaV0pO1xuICBpZiAobWFjcm9NYXRjaCkge1xuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIG1lc3NhZ2U6IG1hY3JvTWF0Y2hbN10sXG4gICAgICB0eXBlOiBlcnIubGV2ZWwydHlwZShtYWNyb01hdGNoWzZdKSxcbiAgICAgIHNldmVyaXR5OiBlcnIubGV2ZWwyc2V2ZXJpdHkobWFjcm9NYXRjaFs2XSksXG4gICAgICBmaWxlOiBtYWNyb01hdGNoWzFdLFxuICAgICAgbGluZTogcGFyc2VJbnQobWFjcm9NYXRjaFsyXSwgMTApLFxuICAgICAgbGluZV9lbmQ6IHBhcnNlSW50KG1hY3JvTWF0Y2hbNF0sIDEwKSxcbiAgICAgIGNvbDogcGFyc2VJbnQobWFjcm9NYXRjaFszXSwgMTApLFxuICAgICAgY29sX2VuZDogcGFyc2VJbnQobWFjcm9NYXRjaFs1XSwgMTApLFxuICAgICAgdHJhY2U6IFtdLFxuICAgICAgZXh0cmE6IHt9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgcGFyc2VkUXR5OiAxICAgIC8vIE51bWJlciBvZiBwYXJzZWQgbGluZXNcbiAgICB9O1xuICB9XG5cbiAgLy8gVHJ5IHRoZSBzaW1wbGVzdCBmb3JtYXQ6XG4gIC8vIGVycm9yOiBtZXNzYWdlXG4gIGNvbnN0IHNpbXBsZU1hdGNoID0gL15cXHMqKGVycm9yfHdhcm5pbmd8bm90ZXxoZWxwKTpcXHMqKC4qKS8uZXhlYyhsaW5lc1tpXSk7XG4gIGlmIChzaW1wbGVNYXRjaCkge1xuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIG1lc3NhZ2U6IHNpbXBsZU1hdGNoWzJdLFxuICAgICAgdHlwZTogZXJyLmxldmVsMnR5cGUoc2ltcGxlTWF0Y2hbMV0pLFxuICAgICAgc2V2ZXJpdHk6IGVyci5sZXZlbDJzZXZlcml0eShzaW1wbGVNYXRjaFsxXSksXG4gICAgICB0cmFjZTogW10sXG4gICAgICBleHRyYToge31cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICBwYXJzZWRRdHk6IDEgICAgLy8gTnVtYmVyIG9mIHBhcnNlZCBsaW5lc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBQYXJzZXMgYSBjb2RlIGJsb2NrLiBJZiBhIG1lc3NhZ2UgcHJvdmlkZWQsIGV4dHJhY3RzIHRoZSBhZGRpdGlvbmFsIGluZm8gKHRoZSBzcGFuIGxlbmd0aCxcbi8vIHRoZSBhZGRpdGlvbmFsIHRleHQgZXRjKSBmcm9tIHRoZSBibG9jayBhbmQgbW9kaWZpZXMgdGhlIG1lc3NhZ2UgaW5mbyBhY2NvcmRpbmdseS5cbi8vXG4vLyBFeGFtbGU6XG4vL1xuLy8gICAgfFxuLy8gMTIgfCAgICBzb21lIGNvZGUgaGVyZVxuLy8gICAgfCAgICAgICAgIF5eXl4gYWRkaXRpb25hbCB0ZXh0XG4vLyAgICA9IG5vdGU6IGFkZGl0aW9uYWwgbm90ZVxuLy9cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBwYXJzZWQgbGluZXMuXG5mdW5jdGlvbiBwYXJzZUNvZGVCbG9jayhsaW5lcywgaSwgbXNnKSB7XG4gIGxldCBsID0gaTtcbiAgbGV0IHNwYW5MaW5lTm8gPSAtMTtcbiAgd2hpbGUgKGwgPCBsaW5lcy5sZW5ndGggJiYgbGluZXNbbF0gIT09ICcnKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2xdO1xuICAgIGxldCBsaW5lUGFyc2VkID0gZmFsc2U7XG4gICAgY29uc3QgY29kZU1hdGNoID0gL15cXHMqKFxcZCopXFxzKlxcfC4qLy5leGVjKGxpbmUpO1xuICAgIGlmIChjb2RlTWF0Y2gpIHtcbiAgICAgIGlmIChjb2RlTWF0Y2hbMV0ubGVuZ3RoID4gMCkge1xuICAgICAgICBzcGFuTGluZU5vID0gcGFyc2VJbnQoY29kZU1hdGNoWzFdLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzcGFuTWF0Y2ggPSAvXltcXHNcXGRdKlxcfChcXHMrKShbXFxeLV0rKVxccyooLiopLy5leGVjKGxpbmUpO1xuICAgICAgICBpZiAoc3Bhbk1hdGNoKSB7XG4gICAgICAgICAgLy8gVGhlIGxpbmUgY29udGFpbnMgc3BhbiBoaWdobGlnaHRcbiAgICAgICAgICBjb25zdCBzdGFydENvbCA9IHNwYW5NYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgbGlnaHQgPSBzcGFuTWF0Y2hbMl07XG4gICAgICAgICAgY29uc3QgbGFiZWwgPSBzcGFuTWF0Y2hbM10ubGVuZ3RoID4gMCA/IHNwYW5NYXRjaFszXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobGlnaHRbMF0gPT09ICdeJykge1xuICAgICAgICAgICAgLy8gSXQncyB0aGUgcHJpbWFyeSBzcGFuLiBDb3B5IHRoZSBoaWdobGlnaHRpbmcgaW5mcm8gdG8gdGhlIG1haW4gbWVzc2FnZVxuICAgICAgICAgICAgbXNnLmNvbF9lbmQgPSBtc2cuY29sICsgbGlnaHQubGVuZ3RoO1xuICAgICAgICAgICAgbXNnLmV4dHJhLnNwYW5MYWJlbCA9IGxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlnaHRbMF0gPT09ICctJyAmJiBsYWJlbCkge1xuICAgICAgICAgICAgLy8gSXQncyBhIHNlY29uZGFyeSBzcGFuLCBjcmVhdGUgYSBzdWJtZXNzYWdlXG4gICAgICAgICAgICBtc2cudHJhY2UucHVzaCh7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGxhYmVsLFxuICAgICAgICAgICAgICB0eXBlOiAnTm90ZScsXG4gICAgICAgICAgICAgIHNldmVyaXR5OiAnaW5mbycsXG4gICAgICAgICAgICAgIGZpbGU6IG1zZy5maWxlLFxuICAgICAgICAgICAgICBsaW5lOiBzcGFuTGluZU5vLFxuICAgICAgICAgICAgICBsaW5lX2VuZDogc3BhbkxpbmVObyxcbiAgICAgICAgICAgICAgY29sOiBzdGFydENvbCxcbiAgICAgICAgICAgICAgY29sX2VuZDogc3RhcnRDb2wgKyBsaWdodC5sZW5ndGgsXG4gICAgICAgICAgICAgIGV4dHJhOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lUGFyc2VkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXV4TWF0Y2ggPSAvXlxccyo9IChub3RlfGhlbHApOiAoLispLy5leGVjKGxpbmUpO1xuICAgICAgaWYgKGF1eE1hdGNoKSB7XG4gICAgICAgIG1zZy50cmFjZS5wdXNoKHtcbiAgICAgICAgICBtZXNzYWdlOiBhdXhNYXRjaFsyXSxcbiAgICAgICAgICB0eXBlOiBlcnIubGV2ZWwydHlwZShhdXhNYXRjaFsxXSksXG4gICAgICAgICAgc2V2ZXJpdHk6IGVyci5sZXZlbDJzZXZlcml0eShhdXhNYXRjaFsxXSksXG4gICAgICAgICAgZXh0cmE6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lUGFyc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsaW5lUGFyc2VkICYmIGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpIHsgIC8vIEdhcHMgaW4gdGhlIHNvdXJjZSBjb2RlIGFyZSBkaXNwbGF5ZWQgdGhpcyB3YXlcbiAgICAgIGxpbmVQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggUnVzdCBwcmlvciB0byAxLjEyLiBSZW1vdmUgdGhpcyBpZi1ibG9jayB3aGVuIHRoZXJlJ3Mgbm8gbmVlZCB0byBzdXBwb3J0IGl0LlxuICAgIGlmICghbGluZVBhcnNlZCAmJiAoL15bXjpdKjooXFxkKylcXHMrLiovLnRlc3QobGluZSkgfHwgL15cXHMrXFxeLiovLnRlc3QobGluZSkpKSB7XG4gICAgICBsaW5lUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxpbmVQYXJzZWQpIHtcbiAgICAgIGwgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGwgLSBpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1lc3NhZ2VCbG9jayhsaW5lcywgaSwgbWVzc2FnZXMsIHBhcmVudE1zZykge1xuICBsZXQgbCA9IGk7XG4gIGNvbnN0IGhlYWRlckluZm8gPSBwYXJzZU1lc3NhZ2VIZWFkZXIobGluZXMsIGkpO1xuICBpZiAoaGVhZGVySW5mbykge1xuICAgIC8vIFRPRE86IEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBSdXN0IHByaW9yIHRvIDEuMTIuIFJlbW92ZSB0aGlzIGlmLWJsb2NrIHdoZW4gdGhlcmUncyBubyBuZWVkIHRvIHN1cHBvcnQgaXQuXG4gICAgaWYgKChwYXJlbnRNc2cgJiYgKGhlYWRlckluZm8ubWVzc2FnZS5zZXZlcml0eSA9PT0gJ2Vycm9yJyB8fCBoZWFkZXJJbmZvLm1lc3NhZ2Uuc2V2ZXJpdHkgPT09ICd3YXJuaW5nJykpXG4gICAgICAgIHx8ICghcGFyZW50TXNnICYmIGhlYWRlckluZm8ubWVzc2FnZS5zZXZlcml0eSAhPT0gJ2Vycm9yJyAmJiBoZWFkZXJJbmZvLm1lc3NhZ2Uuc2V2ZXJpdHkgIT09ICd3YXJuaW5nJykpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBNZXNzYWdlIGhlYWRlciBkZXRlY3RlZCwgcmVtZW1iZXIgaXQgYW5kIGNvbnRpbnVlIHBhcnNpbmdcbiAgICBsICs9IGhlYWRlckluZm8ucGFyc2VkUXR5O1xuICAgIGlmIChwYXJlbnRNc2cpIHtcbiAgICAgIC8vIFdlIGFyZSBwYXJzaW5nIGEgc3VibWVzc2FnZSwgYWRkIGl0IHRvIHRyYWNlXG4gICAgICBwYXJlbnRNc2cudHJhY2UucHVzaChoZWFkZXJJbmZvLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBhcmUgcGFyc2luZyB0aGUgbWFpbiBtZXNzYWdlXG4gICAgICBtZXNzYWdlcy5wdXNoKGhlYWRlckluZm8ubWVzc2FnZSk7XG4gICAgfVxuICAgIGwgKz0gcGFyc2VDb2RlQmxvY2sobGluZXMsIGwsIGhlYWRlckluZm8ubWVzc2FnZSk7XG4gICAgLy8gSWYgaXQncyB0aGUgbWFpbiBtZXNzYWdlLCBwYXJzZSBpdHMgc3VibWVzc2FnZXNcbiAgICBpZiAoIXBhcmVudE1zZykge1xuICAgICAgd2hpbGUgKGwgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgc3ViUGFyc2VkUXR5ID0gcGFyc2VNZXNzYWdlQmxvY2sobGluZXMsIGwsIG1lc3NhZ2VzLCBoZWFkZXJJbmZvLm1lc3NhZ2UpO1xuICAgICAgICBpZiAoc3ViUGFyc2VkUXR5ID4gMCkge1xuICAgICAgICAgIGwgKz0gc3ViUGFyc2VkUXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGwgLSBpO1xufVxuXG5jb25zdCB0cnlQYXJzZU1lc3NhZ2UgPSAobGluZXMsIGksIG1lc3NhZ2VzKSA9PiB7XG4gIHJldHVybiBwYXJzZU1lc3NhZ2VCbG9jayhsaW5lcywgaSwgbWVzc2FnZXMsIG51bGwpO1xufTtcblxuZXhwb3J0IHsgdHJ5UGFyc2VNZXNzYWdlIH07XG4iXX0=
//# sourceURL=/home/takaaki/.atom/packages/build-cargo/lib/std-parser.js
